<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fearless Concurrency - Rust drills, all based on &#x27;The Book&#x27; - the official Rust Programming Language book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_1.html"><strong aria-hidden="true">1.</strong> Rust Overview</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2.html"><strong aria-hidden="true">2.</strong> Rust Cargo</a></li><li class="chapter-item expanded "><a href="../chapter_3/chapter_3.html"><strong aria-hidden="true">3.</strong> Variables and Mutability, Data Types</a></li><li class="chapter-item expanded "><a href="../chapter_4/chapter_4.html"><strong aria-hidden="true">4.</strong> Functions, Comments, Control Flow</a></li><li class="chapter-item expanded "><a href="../chapter_5/chapter_5.html"><strong aria-hidden="true">5.</strong> Programming a 'Guess the number Game'</a></li><li class="chapter-item expanded "><a href="../chapter_6/chapter_6.html"><strong aria-hidden="true">6.</strong> Understanding Ownership</a></li><li class="chapter-item expanded "><a href="../chapter_7/chapter_7.html"><strong aria-hidden="true">7.</strong> References and Borrowing, The Slice data type</a></li><li class="chapter-item expanded "><a href="../chapter_8/chapter_8.html"><strong aria-hidden="true">8.</strong> Using Structs to structure related data</a></li><li class="chapter-item expanded "><a href="../chapter_9/chapter_9.html"><strong aria-hidden="true">9.</strong> Enums and Pattern matching</a></li><li class="chapter-item expanded "><a href="../chapter_10/chapter_10.html"><strong aria-hidden="true">10.</strong> Managing Growing Projects with Packages, Crates, and Module</a></li><li class="chapter-item expanded "><a href="../chapter_11/index.html"><strong aria-hidden="true">11.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_11/chapter_11-1.html"><strong aria-hidden="true">11.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="../chapter_11/chapter_11-2.html"><strong aria-hidden="true">11.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="../chapter_11/chapter_11-3.html"><strong aria-hidden="true">11.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_12/chapter_12.html"><strong aria-hidden="true">12.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../chapter_13/chapter_13.html"><strong aria-hidden="true">13.</strong> Generic Types, Traits, and Lifetimes</a></li><li class="chapter-item expanded "><a href="../chapter_14/chapter_14.html"><strong aria-hidden="true">14.</strong> Writing automated tests</a></li><li class="chapter-item expanded "><a href="../chapter_15/chapter_15.html"><strong aria-hidden="true">15.</strong> Bonus chap (Command Line project chapter)</a></li><li class="chapter-item expanded "><a href="../chapter_16/chapter_16.html"><strong aria-hidden="true">16.</strong> Functional language features - Closures and Iterators</a></li><li class="chapter-item expanded "><a href="../chapter_17/chapter_17.html"><strong aria-hidden="true">17.</strong> More about Cargo and crates.io</a></li><li class="chapter-item expanded "><a href="../chapter_18/chapter_18.html"><strong aria-hidden="true">18.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="../chapter_19/chapter_19.html" class="active"><strong aria-hidden="true">19.</strong> Fearless Concurrency</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust drills, all based on &#x27;The Book&#x27; - the official Rust Programming Language book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fearless-concurreny"><a class="header" href="#fearless-concurreny">Fearless Concurreny</a></h1>
<ol>
<li>
<p>Concurrency is when code pieces run independently of one another</p>
</li>
<li>
<p>Parallelism is when code pieces run simultaneously</p>
</li>
<li>
<p>Rust implements concurrency by using the 1:1 approach</p>
</li>
<li>
<p>The 1:1 approach is when one operating system thread equates to one language thread</p>
</li>
<li>
<p>Threads need to communicate between one another, and share state between one another</p>
</li>
<li>
<p>Rust threads use channels to communicate data; suitable for chat applications</p>
</li>
<li>
<p>Rust allows threads to share data</p>
</li>
<li>
<p>Rust threads done by 'thread::spawn()' returns a trait called JoinThread</p>
</li>
<li>
<p>You can call '.join().unwrap()' on a spawned thread to make sure the process waits until it completes its execution</p>
</li>
<li>
<p>To call 'thread::spawn()', you have to 'use std::thread'</p>
</li>
<li>
<p>Note that 'thread::spawn()' takes in a closure when you specify code to the run by the spawned thread</p>
</li>
<li>
<p>All outer variables (environment variables) captured by 'thread::spawn()' s closure argument must be moved to comply with Rust's ownership rules since threads can outlive the enviroment variables they capture.</p>
</li>
</ol>
<hr />
<ol start="13">
<li>
<p>Thread channels have an upstream transmitter (the data source/producer) and a downstream receiver (the data user/consumer)</p>
</li>
<li>
<p>To create a thread channel, you need to 'use std::sync::mpsc'</p>
</li>
<li>
<p>To create a channel use syntax 'mpsc::channel()'</p>
</li>
<li>
<p>The way Rust's standard library implements channels means a channel can have multiple sending/producing ends that produce values, but only one receiving/consumer end that consumes those values.</p>
</li>
<li>
<ol start="17">
<li>'mpsc::channel' returns a tuple comprising of the transmitter and receiver respective, hence you can destructure this tuple into variables tx and rx.</li>
</ol>
</li>
<li>
<p>Before you can use the transmitter of a given channel inside a 'thread::spawn()', you need to move the transmitter to the closure inside 'thread::spawn()'.</p>
</li>
<li>
<p>To actually send, a.k.a transmit a message (value or data) through a channel's transmitter, you need to the data/value to send() in a call to 'tx.send(the_val).unwrap'</p>
</li>
<li>
<p>Here is demo code of a spawned thread that utilizes a channel to send a message only (don't recv the message just yet);
Here:</p>
</li>
</ol>
<pre><code>  use std::thread;
  use std::sync::mpsc;
  fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
      let data_from_spawned_thread = 5;
      tx.send(data_from_spawned_thread).unwrap().
    });
  }
</code></pre>
<ol start="21">
<li>
<p>The 'send' method of 'tx.send(val)' returns a Result&lt;T, E&gt; type, so if the receiver has already been dropped, i.e, there is no receiver to receive the sent message, the send operation will return an error.</p>
</li>
<li>
<p>Instead of using unwrap all the time, you can match the returned Result to perform hands-on error handling</p>
</li>
<li>
<p>Here is a demonstration code that spawns a thread, and uses a channel to send a message from the spawned thread which is then recieved by any thread; which in this case is the main thread;
Here:</p>
</li>
</ol>
<pre><code>  use std::sync::mpsc;
  use std::thread;
  fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
      let spawned_thread_message = 7;
      tx.send(spawned_thread_message).unwrap();
    });
    let received_message = rx.recv().unwrap();
    println!(&quot;Here is the received message: {}&quot;, received_message);
  }
</code></pre>
<ol start="24">
<li>
<p>'recv()' of 'rx.recv()' returns a Result&lt;T, E&gt;</p>
</li>
<li>
<p>The 'rx' (receiver) of a channel has two methods; 'recv()' and 'try_recv()'</p>
</li>
<li>
<p>The difference between 'rx.recv()' and 'rx.try_recv()' is that;
'rx.recv()' will block other threads from runinng until a Result&lt;T, E&gt; is returned whereby T is not empty and contains an actual message.
whereas,
'rx.try_recv()' never blocks, instead, it will return a Result&lt;T, E&gt; immediately whether or not T contains an actual message, is empty .It will return an Err value if there isn't any message.
N.B:
'rx.recv()' will only return an Err when the transmitter closes, so it can signal that no more values will be coming.</p>
</li>
<li>
<p>Note the following concepts about sharing state:</p>
</li>
</ol>
<ul>
<li>A Mutex which means mutual exclusivity is how you share state between threads.</li>
<li>The concept of mutexes is that only one thread can access data at a given time.</li>
<li>Mutexes have locks which are data structures that keep track of which thread is currently holding/accessing the data (in a mutex).</li>
<li>To successfully share data, you must first notify a mutex holding the data you want that you wish to acquire the lock on it, after which the data will become available once the current thread that has the lock releases the lock, then..you too must release the lock you acquired.</li>
</ul>
<ol start="28">
<li>Here is a basic code that creates and uses a Mutex
Here:</li>
</ol>
<pre><code>  use std::sync::Mutex;
  fn main() {
    let m = Mutex::new(5);
    {
      let mut num = m.lock().unwarp();
      *num = 6;
    }
    println!(&quot;The mutex m holds value m: {}&quot;, m);
  }
</code></pre>
<p>|&gt;: m = Mutex { data: 6, poisoned: false, .. }</p>
<p>The call to 'lock()' will block the current thread so it can't do any work until it's out turn to have the lock.</p>
<ol start="29">
<li>
<p>The call to 'lock' would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so the code has an 'unwrap()' which would have the thread attempting to hold the lock, panic.</p>
</li>
<li>
<p>After the lock of a mutex has been acquired, you can treat the return value (of calling the_mutex.lock().unwrap()) as a mutable reference to the data inside. The type system ensures that you acquire the lock first, before using the value inside the mutex.</p>
</li>
<li>
<p>Mutex<T> is a smart pointer, and the call to 'lock' returns a smart pointer called 'MutexGuard' wrapped in a 'LockResult' (which may be handled with the call to 'unwrap').</p>
</li>
<li>
<p>The 'MutexGuard' smart pointer implements 'Deref' to point at the inner data of the mutex. It also implements 'Drop' that releases the lock automatically when a 'MutexGuard' goes out of scope.</p>
</li>
</ol>
<hr />
<ol start="33">
<li>Here's a simple demonstration code that spawns multiple thread with data shared between them;
Here:</li>
</ol>
<pre><code>  use std::sync::{Arc, Mutex};
  use std::thread;
  fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..10 {
      let counter = Arc::clone(&amp;counter);
      let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();
        *num += 1;
      });
      handles.push(handle);
    }
    for handle in handles {
      handle.join().unwrap();
    }
    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
  }
</code></pre>
<ol start="34">
<li>
<p>The 'Send' marker trait indicates that ownership of values of the type that implements it can be transferred between threads.</p>
</li>
<li>
<p>The 'Sync; marker trait indicates that the values of the type that implements it can be referenced from multiple threads.</p>
</li>
<li>
<p>An type T that implements 'Send', that is referenced immutably (i.e, &amp;T), is inherently also 'Sync'.
So, you become 'Sync' if you're a 'Send' that is immutably referenced.</p>
</li>
<li>
<p>Types that implement 'Send' and/or 'Sync' by default are call a Send and/or a Sync.</p>
</li>
<li>
<p>Implementing 'Send' and 'Sync' manually involves implementing unsafe Rust code.
Note that building new concurrent types not made up of Send and Sync parts (i.e, manual implementation) requires careful thought to uphold the safety guarantees that Rust demands.</p>
</li>
</ol>
<p>Completed On: Saturday, July 23, 2022.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_18/chapter_18.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_18/chapter_18.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
