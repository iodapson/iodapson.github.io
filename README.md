
## RUST DRILLS

## RUST OVERVIEW

### 1. What example type of software or apps can you build with Rust?

- Command Line: Whip up a CLI tool quickly with Rust's robust ecosystem. Rust helps you maintain your app with confidence and distribute it with ease
- WebAssembly: Use Rust to supercharge your JavaScript, one module at a time. Publish to npm, bundle with webpack, and you're off to the races
- Networking: Predictable performance. Tiny resource footprint. Rock-solid reliability. Rust is great for network services
- Embedded: Targeting low-resource devices? Need low-level control without giving up high-level conveniences? Rust has you covered.


### 2. Where do you install rust from?

This webpage: https://www.rust-lang.org/tools/install


### 3. Where is the place to try out Rust online?

This webpage:
https://play.rust-lang.org/


### 4. How do you check if you have Rust installed on your system/machine?

By typing out the shell/cmd command:
```
$ rustc --version
```
Note: This is also how you check the installed version of your Rust


### 5. How do you update your Rust version to the latest one?

By inputting the shell/cmd command:
```
$ rustup update
```


### 6. How do you build your Rust project/file?

By running the command:
```
$ cargo build
```


### 7. How do you run your Rust project/file?

By running the command:
```
$ cargo run
```


### 8. How do you test your Rust project/folder?

By running command:
```
$ cargo test
```


### 9. How do you build documentation for your Rust project?

By running command:
```
$ cargo doc
```

### 10. How do you publish your Rust project as a library to crates.io?

By running command:
```
$ cargo publish
```


### 11. Mention a few editor where you can write and develop Rust projects

VS Code, Sublime Text, Atom, IntelliJ Idea, Eclipse, Vim, Emacs, Geany.


### 12. How do you conveniently generate a new Rust project using cargo?

By running command:
```
$ cargo new your-rust-project-name
```


### 13. Describe the structure of an auto-generated Rust project from cargo

your-rust-proect-name
```
| - Cargo.toml
|- src
  |- main.rs
  
 ```


### 14. Describe the Rust project file "Cargo.toml"

It is the manifest file for Rust. It is where you keep metadata for your project, as well as dependencies


### 15. Where or what file will you write your application code in?

"src/main.rs"
Other files that has suffix ".rs" can also make up part of your Rust application code.


### 16. Where or what folder will you find all of your Rust's development environment's tools in?

Inside folder structure:
"~/.cargo/bin"
Here, you will find Rust toolchains, such as;
rustc, cargo, and rustup.
Also note that this folder structure will be included in your PATH environment variable when you install Rust, by default, however, if it isn't, then you should include it.


### 17. How do you know whether or not the folder structure "~/.cargo/bin" has been included inside your PATH environment variable during an installation of rustc?

By running the command:
```
$ rustc --version
```
If this command fails despite having installed rustc, then it means that you have to manually include the folder structure "~/.cargo/bin" inside your PATH environment variable.


### 18. How do you go about uninstalling Rust from your machine?

By entering the shell/cmd command:
```
$ rustup self uninstall
```


Completed On: Saturday, April 30, 2022.


##   RUST CARGO

### 1. What is Rust style of indentation?

Indenting with four spaces, instead of a tab, or even two spaces.


### 2. What does an exclamation mark (!) with a variable name mean in Rust?

It means you are calling a macro.


### 3. Do macros follow the same rules as functions in Rust?

No, macros don't always follow the same rules as functions in Rust.


### 4. How many files are emitted when you run the Rust command "rustc main.rs" on Linux and macOS?

One file, namely; main.exe


### 5. How many files are emitted when you run the Rust command "rustc main.rs" on Windows?

Two files, namely; main.exe & main.pdb


### 6. Describe the main.pdb file generated by "rustc" compilation command on Windows

It is a file that contains debugging information.


### 7. What is Rust's build system and package manager?

Cargo


### 8. As a Rustacean, what might you use Cargo for?

As a tool to manage my Rust project, like;
- building my code (different from compilation)
- downloading the libraries my code would depend on or already depends on
- building libraries my code would depend on or already depends on


### 9. What are libraries that your code depend on called?

dependencies


### 10. How do you check for Cargo installment on your machine?

By applying command:
```
$ cargo --version
```
If you get a Cargo version number, it means you have Cargo installed, whereas you'll get an error if you do not have it installed.


### 11. What files does the Cargo command "cargo new project-name" generate?

Three files;
- Cargo.toml
- .gitignore
- main.rs nested inside a 'src' top-level folder of your project


### 12. How do you override the behavior of "cargo new project-name" generating a '.gitignore' file?

By running the Cargo command;
```
$ cargo new --vcs=git
```


### 13. What does the 'TOML' suffix of the generated 'Cargo.toml' file mean?

It means "Tom's Obvious, Minimal Language. It is a file format.


### 14. What are packages of code in Rust referred to?

crates


### 15. What example type of files can be contained inside your top-level project directory alongside the 'src' folder and Cargo's "Cargo.toml" file?

README files, license information, configuration files, and anything else not related to your code.


### 16. Where does Cargo expect your code files to live in?

Inside the "src" folder inside your top-level project directory.


### 17. Where does the Cargo command "cargo build" store the resulting compilation or executable?

On Windows, it is: ".target\debug\project_name.exe"
On macOS, it is: ".target/debug/project_name.exe"


### 18. What additional new file does running Cargo command "cargo build" for the first time create inside your top-level project directory?

Cargo.lock


### 19. What is the "Cargo.lock" file about?

It keeps track of the exact versions of dependencies in your project for you automatically.


### 20. What does the command "cargo run" do for you?

It first builds or rebuild your Rust cargo projects, and then run the generated executable of it


### 21. Why would you consistently run the Cargo command' "cargo check"?

To continually check your work while writing the code, to make sure your program compiles, hence telling you that you have made no mistakes that would lead to a failed compilation process


### 22. Cargo command "cargo check" compiles your code, but does it also generate or produce an execuatable?

No


### 23. What Cargo command do you use to build an executable that is most suitable and optimized for release?
```
$ cargo build --release
```


### 24. Demonstrate a chain of commands (Git and Cargo commands), which you can use to clone a Rust project from GitHub or any other VCS, and then build the project locally on your machine
```
$ git clone example-vcs.org/someproject
$ cd someproject
$ cargo build
```


Completed On: Tuesday, May 3, 2022.


##   VARIABLES AND MUTABILITY, DATA TYPES

### 1. Variables in Rust are immutable by default. How can you make a mutable Rust variable?

By using the keyword "mut" in your variable declaration, like this:
```
let mut variable-name = 5;
```


### 2. What syntax is used as a placeholder inside strings, when you plan to access a variable's value inside the string?

{}
For example, you use it like this:
```
  let a = 8;
  println!("The value of variable a is: {}", a);
```  
Output: 
The value of variable a is: 8


### 3. How do you specify valid strings in Rust?

With a pair of double quotes("..."), instead of single quote pairs ('...').


### 4. How do you create a constant variable in Rust?

By using the "const" keyword alongside a variable name written in all-caps, and annotating its data type.


### 5. Give an example Rust constant variable declaration
```
  const THREE_HOUR_IN_SECONDS: u32 = 60 * 60 * 3;
```  


### 6. What is the validity period of a Rust constant variable?

The entire time a Rust program runs. It seems to me that this means that they are not garbage collected.


### 7. Take note of variable shadowing

E.g,
```
  fn main() {
    let spaces = "     ";
    let spaces = spaces.len();
    let a = 7;
    let a = a + 1;
    {
      let a = a * 2; // 16
      println!("The value of a in this inner scope is: {}", a);
    }
    println!("The value of a is: {}", a); // 8
  }
```  


### 8. Take a look at this code;
  let mut spaces = "    ";
  spaces = spaces.len();
..and decide if Rust lets you mutate types, as done here (from string to number)

No, such operation would cause a compilation error


### 9. Mention two data type subsets in Rust

- scaler
- compound


### 10. What does the 'stdio()' code snippet, relative to 'io' mean?
  io::stdin()
..mean?

It means "stdin" is an associated function that is implemented on type "io" that is being accessed.


### 11. A scaler type represents a what?

A single value.


### 12. What are the four primary scaler types in Rust?

- integers
- foating point numbers
- Booleans
- characters


### 13. List all the unsigned integer types available to you in Rust

They are:
- u8
- u16
- u32
- u64
- u128
- usize (has a length arch)


### 14. List all the signed integer types available to you in Rust

They are:
- i8
- i16
- i32
- i64
- i128
- isize (has a arch variable-length)


### 15. What is the difference between a signed integer and an unsigned integer type?

A signed integer is usually used to represent and store negative numbers. Note that you can also store positive numbers using a signed integer type as well.
Whereas, an unsigned integer type is used to represent and store positive numbers only.


### 16. What is the range of possible numbers that a signed integer of a given type is able to store.

Representing the bit length of the signed integer type with character 'n', we can calculate the range of values possible using the formula;
  -(2^(n-1)) to 2^(n-1) - 1
For example;
i8 can store a range of..
  -(2^(8-1)) to 2(^8-1) - 1
  = -2(^7) to 2(^7) - 1
    = -128 to 128 - 1
      = -128 to 127 integer values.


### 17. What is the range of possible numbers that an unsigned integer of a given type is able to store.

Representing the bit length of the signed integer type with character 'n', we can calculate the range of values possible using the formula;
  0 to 2^n - 1
For example;
u8 can store a range of..
  0 to 2^8 - 1
    = 0 to 256 - 1
      = 0 to 255 integer values.


### 18. What does the "isize" and "usize" integer types depend on?

The architecture of the computer your program is running on, which is denoted as "arch". For example, 64 bits if you're on a 64-bit architecture and 32 bits if you're on a 32-bit architecture.


### 19. What separator can you use in the representation of integer values in Rust, that would be ignored by the Rust compiler, and not affect the literal value you specify?

The underscore _
With it, you can represent literal value 1000 either as 1000 or as 1_000. They both specify the same integer literal value.


### 20. Write an example of a Decimal (base 10) integer literal value

98_222


### 21. Give an example of a Hex (base 16) integer literal value

0xff


### 22. Write out an example of a Octal (base 8) integer literal value

0o77


### 23. Give an example of a Binary (base 2) integer literal value

0b1111_0000


### 24. Write an example of a Byte (u8 only) integer literal value

b'A'


### 25. What do you do when you do not know which type of integer to use?

Don't specify an integer type, which will cause your program to use Rust's default integer type of choice.


### 26. What is Rust's default integer type of choice?

i32


### 27. In what primary situation would you use integer types isize or usize?

When indexing some sort of collection.


### 28. Explain what integer overflow is with an example illustration

Let's say you have a variable of type u8 that can hold values between 0 and 255. Now, if you try to change the variable to a value outside of that range, such as 256, Integer overflow will occur.


### 29. How does Rust react of integer overflow scenerios?

In debug mode: Your program will panic at runtime and then exit with an error, when it checks your program for integer overflow.
In release mode: It won't panic. Rather, two's complement wrapping occurs. For example, in the case of a u8, the value 256 becomes 0. In case of u8 with an acribed value 257, becomes 1.


### 30. Relying on integer overflow's wrapping behavior is considered what?

An error.


### 31. What methods are provided by the Rust standard libray for primitive numeric types, to handle the possibility of overflow?

- Wrap all modes with the..
  wrapping_*
..methods, such as..
  wrapping_add
- Return the..
  None
..value if there is overflow with the..
  checked_* methods
- Return the value and a boolean indicating whether there was overflow with the..
  overflowing_*
..methods
Saturate at the value's minimum or maximum values with..
  saturating_*
methods.
Learn more about these later.


### 32. What floating-point types are available in Rust?

f32 & f64


### 33. What is default floating-point type used by Rust, provided you do not specify any?

f64


### 34. What is, or are the differences between f32 & f64?

- Although they both have roughtly the same speed, f64 however has superior precision.
- f32 is a single-precision float, whereas f64 has double precision.


### 35. Are all floating point numbers signed or unsigned?

They are signed.


### 36. Floating-point numbers are represented according to what standard?

The IEEE-754 standard.


### 37. Demonstrate creating a variable with an annotated float integer data type

Here:
  fn main() {
    let x: f32 = 3.0 // f32 data type variable
    let y = 4.0 // f64 data type variable
  }


### 38. Demonstrate code that showcases some basic numeric (integer) operations you can perform with Rust
```
  fn main() {
    // addition
    let _sum = 5 + 10;

    // subtraction
    let _difference = 95.5 - 4.3;

    // multiplication
    let _product = 4 * 30;

    // division
    let _quotient = 56.7 / 32.2;
    let _floored = 2 / 3; // Results in 0

    // remainder
    let _remainder = 43 % 5;

    println!(
        "addition: {} \ndifference: {} \nproduct: {} \nquotient: {} \nfloored: {} \nremainder: {}",
        _sum, _difference, _product, _quotient, _floored, _remainder
    )
  }
```  


### 39. How do you specify a char (character) data type variable in Rust?

By enclosing the character inside a pair of single quotes, like this:
```
  fn main() {
    let c = 'z';
    let z = 'Z';
  }
```  


### 40. What is the byte size of the "char" data type in Rust?

Four bytes.


### 41. What does the "char" data type represent in Rust?

Unicode Scaler Value.


### 42. Mention sample characters that Rust's "char" data type can represent?

- accented letters: Chinese, Japanese, Korean
- emojis
- zero-width spaces, as in: ''


### 43. What is the range of Unicode Scaler Values in Rust?

U+0000 to U+D7FFF
and..
&
U+E0000 to U+10FFFF
..inclusive.


### 44. What are Compound types in Rust?

They are a mechanism that allows you to group multiple values into one type.


### 45. What are the two primitive compound types in Rust?

- tuples
- arrays


### 46. What is a Rust tuple?

A tuple is a compound type that gives you the means to group together a number of values of the same type only into one.
It has a fixed length, so they cannot grow or shrink in size.


### 47. Demonstrate code that creates a Rust tuple

Here:
```
  fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1); // creation of a tuple variable called 'tup'. Note that 'tup' here has annotated data types, but you don't have to do so all the time
  }
```  


### 48. Demonstrate code that uses pattern matching to destructure a tuple's constituent values into separate variables

Here:
```
  fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {}", y); // Outputs 6.4
  }
```  


### 49. Demonstrate code that accesses a tuple's constituent values, using a period to acesss specific tuple indices, instead of pattern-matching based destructuring

Here:
```
  fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0; // 500
    let six_point_four = x.1; // 6.4
    let one = x.2; // 1
  }
```  


### 50. What is a 'unit type' in Rust?

It is a tuple without any value, represented by..
()


### 51. What is the value of the 'unit type' in Rust called?

'unit value', also represented by..
()


### 52. What do expressions implicitly return when they don't have an explicitly returned value?

A unit value


### 53. What is a Rust array?

An array is a compound type that gives you the means to group together a number of values with the same type into one.
It has a fixed length, so they cannot grow or shrink in size.


### 54. Demonstrate code that creates a Rust array

Here:
```
  fn main() {
    let a = [1, 2, 3, 4, 5];
  }
```  
Another example:
```
  fn main() {
    let a: [i32; 4] = [3, 4, 5, 6];
  }
```  


### 55. When, in what two cases, would you typically use an array in Rust code?

- When you want data allocated on the stack rather than on the heap.
- When you want to ensure that you always have a fixed number of elements.


### 56. When may you choose a vector over an array?

- If you're unsure whether to use an array or a vector.
- If you want to be able to shrink or grow the size of what holds your data.


### 57. What is the major difference between an array and a vector?

An array's size can never increase nor decrease, whereas, a vector's size can.


### 58. Demonstrate code that initializes an array to contain the same value for each element by specifying the initial value at its point of creation

Here:
```
  fn main() {
    let a = [3; 5];
  }
```  
The code here above, creates an array called 'a' that will contain 5 elements that will all be set to the value of 3 initially. The code is equivalent to writing..
  let a = [3, 3, 3, 3, 3];
..but in a more concise way.


### 59. Demonstrate code that access elements of an array, using indexing of course!

Here:
```
  fn main() {
    let a = [1, 2, 3, 4. 5];
    let first = a[0];
    let second = a[1];
  }
```  
In the above example, the variable 'first' will get the value 1 because that is the value at index [0] in the array, whereas, the variable named 'second' will get the value 2 from index [1] in the array.


### 60. What happens to your Rust program when you try to access an array by an index greater than or equal to the length figure of the array?

Rust panics and exit your program.


Completed On: Wednesday, May 4, 2022. 10:24PM.


## FUNCTIONS, COMMENTS, CONTROL FLOW

### 1. Demonstrate code that creates a function with one or more parameter(s)

Here:
```
  fn another_function(x: i32) {
    println!("The value of parameter x: {}");
  }
  fn main() {
    another_function(50);
  }
``  
Another example:
```
  fn main() {
    print_labeled_measurements(5, 'h');
  }
  fn print_labeled_measurements(value: i32, unit_label: char) {
    println!("The measure is: {}{}", value, unit_label);
  }
```  
Output: 
|>The measurement is: 5h


### 2. In Rust's function signatures, you must declare the type of each parameter, true or false?

True. 


### 3. What are Rust statements?

They are instructions that perform some action and do not return a value.


### 4. What are Rust expressions?

They are constructs that *evaluate* to a resulting value.


### 5. Give two examples of a statement

i) Variable declaration/initializate:
  let y = 6;
ii) Function declaration:
  fn some_function() {
    //...
  }


6. In Rust, unlike say Ruby and C, variable declarations/assignments returns the value of the assignment. Now showcase such code (which mind you, is illegal in Rust)

Here:
  let x = y = 7;


7. Give 3 examples of an expression

- the value assigned to a variable initialization, e.g:
  let y = 4; 
The number 4 here, is an expression, since it evaluates to the integer value 4.
- function call
- macro call
- block scoping with curly brackets, e.g:
  fn main() {
    ..now the block scope
    let y = {
      let x = 3;
      x+ 1 //This expression gets returned
    };
    println("The value of y is: {}", y);
  }
|> The value of y is: 4


8. Examine the following block scope code:
  {
    let x = 3;
    x + 1 // no semi-colon termination
  }
..explain what would happen if you were to add a semi-colon termination to the 'x + 1' code line in the above code

It would turn the code line to a statement, and when that happens, it will not return a value, since statements never evaluate to a value.


9. Demonstrate code that creates a Rust function which returns a value

Here:
  fn five() -> i32 {
    5
  }
  fn main() {
    let x = five();
    println!("The value of x is: {}", x);
  }
*In the above code, notice the syntax '->' used to indicate the data type of the returned value, and how the returned value itself is an expression on the last line of the function returning it.
- Another example:
  fn main() {
    let x = plus_one(5);
    println!("The value of x is: {}", x);
  }
  fn plus_one(x: i32) -> i32 {
    x + 1
  }
- Yet, another example:
  fn main() {
    let something = explicit_return();
  }
  fn explicit_return() -> i8 {
    return 'C';
  }
Here, a return statement is used to return a value from inside function 'explicit_return'.


10. How do you write single line comments in Rust?

With the double forward slash, as in:
  //


11. How do you write multi-line comments in Rust?

By writing multiple single-line comments, each one on its own line, like this:
  // line 1..
  // line 2
  // line 3


12. Demonstrate code that creates an if..else block in Rust

Here:
  fn main() {
    let x = 5;
    if x > 0 {
      println!("x is greater than 0, has the value: {}", x);
    } else {
      println!("The value of x is less than 0, has the value: {}", x);
    }
  }


13. Can you use expressions other than a bool in an if..else Rust construct, like this:
  fn main() {
    let a = 1;
    if a { // * take note
      println!("a is truthy");
    }
  }

No! There is no concept of truthy values in Rust as of May, 2022.


14. Demonstrate code that creates multiple conditions with else..if constructs in Rust

  fn main() {
    let number = 6;
    if number % 5 == 0 {
      println!("number is divisible by 5");
    } else if number % 3 == 0 {
      println!("number is divisible by 3");
    } else if number % 2 == 0 {
      println!("number is divisible by 2");
    } else {
      println!("number is not divisible by 5, 3, 2");
    }
  }
|> number is divisible by 3
Rust executes the first body for which the condition holds true.


15. Making use of too many chains of else..if constructs in your Rust code could make your code cluttered. What alternate construct can you use to avoid the clutter?

"match"


16. Demonstrate code that implicitly returns a value from an if..else construct to assign it to a variable

Here:
  fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };
    println!("The value of number is: {}", number);
  }


17. What happens when you assign an if..else construct, each containing different implicitly returned data type expressions to a variable, like this:
  let number = if condition { 5 } else { "six" };

You'll get a compile error.


18. What constructs are available to you in Rust for creating loops?

- 'loop'
- 'while'
- 'for', as in for..in


19. Demonstrate code that creates a loop using the 'loop' construct

Here:
  fn main() {
    loop {
      println!("again!");
    }
  }
This code demo creates an infinite loop, unless you terminate your program manually, by using ^C (Ctrl+c).


20. Demonstrate code that breaks a 'loop' construct from inside the code

Here:
  fn main() {
    let mut counter = 0;
    loop {
      counter += 1;
      if counter == 10 {
        break;
      }
    }


21. Just like with if..else, else..if blocks, you can also implicitly return expression-values from a 'loop' construct, true or false?

True.


22. Demonstrate code that implicitly returns an expression value from a 'loop' construct

Here:
  let mut counter = 0;
  let result = loop {
    counter += 1;
    if counter == 10 {
      break counter * 2; // the implicitly returned expression value comes bundled with the loop's break (termination). It's like saying; break with this return value. 
      // Note the semi-colon termination in "break counter * 2;" because break is actually a statement. "continue" is another loop control statement.
    }
  }; // semi-colon exists here too because ' let result = loop { ... } ' above is indeed a statement.


21. Does the concept of outer-loop label exist in Rust?

Yes. It is written as;
  'the_outer_loop_name: loop { ... }


22. Demonstrate code that creates and terminates an outer-loop label, otherwise simply known as a loop label

Here:
  fn main() {
    let mut count = 0;
    // outer labeled 'loop' construct
    'counting_up: loop {
      println!("count = {}", count);
      let mut remaining = 10;
      // innner 'loop' construct
      loop {
        println!("remaining = {}", remaining);
        if remaining == 9 {
          break;
        }
        if count == 2 {
          break 'counting_up;
        }
        remaining -= 1;
      } // end of inner loop
      count += 1;
    } // end of outer loop
    println!("End count = {}", count);
  }
Notice how the outer labeled 'loop' construct is created and referenced as 'counting_up
|>
  count = 0
  remaining = 10
  remaining = 9
  count = 1
  remaining = 10
  remaining = 9
  count = 2
  remaining = 10
  End count = 2


23. Demonstrate code that utilizes the 'while' loop construct of Rust

Here:
  fn main() {
    let mut number = 3;
    while number != 0 {
      println!("{}!", number);
      number -= 1;
    }
    println!("LIFTOFF!!!);
  }


24. Demonstrate code that uses the 'while' construct to loop over the elements of a collection, such as an array

Here:
  fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;
    while index < 5 {
      println!("the value is: {}", a[index]);
      index += 1;
    }
  }


25. Demonstrate code that use the 'for' construct of Rust to loop over the elements of a collection, such as an array

Here:
  fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a {
      println!("the value is: {}", element);
    }
  }


26. When is a 'for' construct especially better than a 'while' construct?

When your collection's size increases or decreases, you wouldn't have to go back to update your boolean condition(s) as you would in a "while" constuct.


27. Demonstrate code that uses the 'for' construct to print a range of number values

Here:
  fn main() {
    for number in (1..4).rev() {
      println!("{}!", number);
    }
    println!("LIFTOFF!!!");
  }


Completed On: Sunday, May 8, 2022. 10:52AM.
